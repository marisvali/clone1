Description
-----------

This project is a clone of a game on poki.com, "Merge the Numbers":
https://poki.com/ro/g/merge-the-numbers#fullscreen

It aims to follow the official/original game's behavior as closely as possible, except where something was clearly a bug or undesired effect.

Motivation
----------

The point of this project was to practice implementing a simple 2D game using my current tech stack (Go, Ebitengine). More specifically, the point is to see what it takes to implement such a game fully, not just a proof of concept or a working prototype, but everything, down to the last detail of the UI (within reason). This is not meant for public release, commercial or otherwise, it is a personal project for personal use.

Regression tests
----------------

A number of tests were created in regression-tests. Each test consists of:
- A .txt file that describes what the test consists of.
- A .clone1 file. This is the recorded playthrough. It should exhibit the behavior described in the .txt file.
- A .clone1-hash file. This holds the hash generated by the playthrough when the playthrough was recorded and evaluated as ok.
- An optional .yaml. This can be used to set up the initial state of the game, when recording the playthrough.

These tests are meant to be executed after World is modified in a way that is meant to be non-breaking (e.g. refactors and bug fixes). They are executed by running TestWorld_RegressionTests. If everything passes, then the modifications didn't break anything.

How to create a test:
- Create the .txt file, with two parts. The "Setup" part describes what the initial state is and what actions the player should take. The "Test" part describes the expected behavior of the game.
- Optionally create a .yaml file that sets the initial game state to the state described in the .txt file.
- Run the game with recording enabled and follow the instructions in the .txt file. Try to notice if the game behaves as the .txt expects it to. If you're not sure, replay the recording and see.
- Copy and rename the last-recording.clone1 file.
- Create a corresponding .clone1-hash file, empty.
- Run TestWorld_RegressionTests. It will complain that the actual hash doesn't match the expected hash. Copy the actual hash in the .clone1-hash file.
- Run TestWorld_RegressionTests again to make sure the test passes.
- Now whenever the code in World changes, you can re-run the test and it should produce the same hash, unless the logic in the World changed such that the hash cannot match anymore.

Sometimes breaking changes are required, and they cause tests to fail. There are several cases:
1. The World changed in such a way that a different hash is generated and this cannot be avoided, but you can replay the .clone1 file and see that it exhibits the behavior described in the .txt file. In this case, simply overwrite the .clone1-hash with the new expected hash.
2. The PlayerInput or Level structures changed. Even if the logic of the test is not affected at all, the tests are invalidated because the .clone1 files cannot be deserialized correctly anymore. It can be tempting at this point to try to convert from the old format to the new one, using some custom code. I've tried this a few times and my experience has been that it takes longer to do this conversion than to simply re-record the tests.
3. The World changed in such a way that the .clone1 files no longer exhibit the behavior described in the .txt files. If the general logic in the .txt file still applies, the test must be re-recorded.

To re-record a test:
- Delete the .clone1 file.
- Copy the contents of the test's .yaml file (if you have it) to your test-dev.yaml file.
- Read the .txt file and see what the instructions say to do.
- Run the game and perform the actions described by the .txt file. Make sure that recording to file is enabled.
- If you make a mistake, simply press R and try again, the recording will be re-created from scratch.
- Copy the last-recording.clone1 file, rename it, generate the hash for it and copy it to the .clone1-hash file.

Idea for improving regression tests
-----------------------------------

The test consists of 3 parts:
1. The initial state. This has been automated using the test .yaml files.
2. A series of player inputs. Currently, the inputs are given manually.
3. The evaluation that the game behaves correctly, given the initial state and the inputs. Currently, this evaluation is done manually.

It would not be very difficult to automate part 2, the giving of inputs. They can be a series of actions such as "move mouse to x, y", "wait", "press" and "release". This list of instructions can even be given as an optional part of the .yaml. This way, most small, finicky tests for edge cases can be regenerated automatically. However, the evaluation is not as simple to automate, and it involves understanding the test thoroughly anyway, which is the biggest pain point when re-creating the tests.

Another idea might be to just make it easier to re-run and validate a test. Currently, a lot of manual manipulation of files is needed. This is not very difficult, but it requires care and feels like a chore.

---------------------------------------------------------
This README was last reviewed and updated on: 2025-12-26.